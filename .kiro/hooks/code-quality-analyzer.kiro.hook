{
  "enabled": true,
  "name": "Code Quality Analyzer & Brain Updater",
  "description": "Monitors source code files for changes and analyzes them for code smells, design patterns, and best practices. Generates suggestions for improving code quality, readability, maintainability, and performance while updating the Jarvis brain architecture with insights.",
  "version": "1",
  "when": {
    "type": "fileCreated",
    "patterns": [
      "core/*.py",
      "execution/*.py",
      "storage/*.py",
      "monitoring/*.py",
      "voice/*.py",
      "server/*.py",
      "jarvis.py",
      "jarvis_master.py",
      "start_jarvis.py"
    ]
  },
  "then": {
    "type": "askAgent",
    "prompt": "Analyze the modified code files for potential improvements. Focus on:\n\n1. **Code Quality Analysis:**\n   - Identify code smells (duplicated code, long methods, large classes, etc.)\n   - Suggest design pattern applications (Factory, Strategy, Observer, etc.)\n   - Recommend best practices for Python (PEP 8, type hints, docstrings)\n   - Evaluate readability and maintainability\n   - Identify performance optimization opportunities\n\n2. **Jarvis Brain Architecture Updates:**\n   Based on the code changes, update the Jarvis brain with:\n   - **Intent Classification improvements**: New intents or entity patterns discovered\n   - **Router Logic enhancements**: Better decision-making flows or tool routing\n   - **Tool Module optimizations**: Improved modular design or new capabilities\n   - **Memory Context insights**: Better context tracking or personalization opportunities\n   - **Prompt Engine refinements**: Enhanced magical personality or response formatting\n   - **Output Formatter improvements**: Better markdown, emoji usage, or themed phrases\n\n3. **Actionable Recommendations:**\n   - Provide specific code refactoring suggestions with examples\n   - Maintain existing functionality while improving structure\n   - Prioritize changes by impact (high/medium/low)\n   - Consider the modular architecture (Brain Core, Tool Modules, Memory Context)\n\n Jarvis Brain Architecture \n1. Intent + Entity Parsing\nUse:\n- Dialogflow CX for high-level intent classification\n- spaCy for entity extraction (e.g., mod name, config file)\n- Sentence Transformers for semantic similarity (fallback matching)\n 2. RouterChain: The Brain Core\nUse LangChain‚Äôs RouterChain or your own logic to:\n- Match intent to tool/module\n- Handle fallback or multi-step flows\n- Log decisions for debugging\n 3. Tool Modules (APIs + Local Models)\nEach feature lives in its own module:\n- grammar_tool.py ‚Üí uses spaCy + transformers\n- quiz_generator.py ‚Üí calls LangChain + generate_quiz\n- mod_parser.py ‚Üí parses config DSL, validates syntax\n- weather_fetcher.py ‚Üí calls OpenWeatherMap API\n- vision_module.py ‚Üí uses OpenCV + OCR\n\n4. Memory + Context Manager\nTrack:\n- Student preferences (e.g., prefers analogies)\n- Session history (e.g., last quiz score)\n- Emotional tone (e.g., frustration detected)\nUse:\n- LangChain ConversationSummaryMemory\n- Redis or JSON-based store for persistent memory\n4. Memory + Context Manager\nTrack:\n- Student preferences (e.g., prefers analogies)\n- Session history (e.g., last quiz score)\n- Emotional tone (e.g., frustration detected)\nUse:\n- LangChain ConversationSummaryMemory\n- Redis or JSON-based store for persistent memory\n6. Output Formatter\nStyle responses with:\n- Markdown for clarity\n- Emojis for engagement\n- Themed phrases (‚ÄúLet‚Äôs cast a quiz spell!‚Äù)\nre Components:\n- Intent Classifier: Dialogflow CX, spaCy, or Sentence Transformers\n- Router Logic: LangChain RouterChain, or custom Python switchboard\n- Fallback Handler: Clarifies ambiguous input or re-prompts\nüßô Example Flow:\ndef brain_core(user_input, context):\n    intent = classify_intent(user_input)\n    if intent == \"grammar\":\n        return grammar_tool(user_input)\n    elif intent == \"quiz\":\n        return quiz_generator(user_input)\n    elif intent == \"modding_help\":\n        return mod_parser(user_input)\n    elif intent == \"vision\":\n        return vision_module(user_input)\n    else:\n        return ask_for_clarification(user_input)\n\n\n\nüß∞ 2. Tool Modules ‚Äì Specialized Executors\nEach feature lives in its own module, callable by the Brain Core.\nüîß Examples:\n- grammar_tool.py ‚Üí grammar correction via spaCy + transformers\n- quiz_generator.py ‚Üí LangChain + generate_quiz\n- mod_parser.py ‚Üí Minecraft config validator (regex + AST)\n- vision_module.py ‚Üí OpenCV + OCR\n- weather_fetcher.py ‚Üí REST API to OpenWeatherMap\nüßô Modular Design:\ndef grammar_tool(text): ...\ndef quiz_generator(topic): ...\ndef mod_parser(config): ...\ndef vision_module(image): ...\n\n\nEach module should:\n- Accept structured input\n- Return structured output (text, JSON, image, etc.)\n- Be stateless (context handled by Brain Core)\n\nüßµ 3. Memory Context ‚Äì Adaptive Intelligence\nJarvis becomes magical when it remembers:\n- Student preferences (e.g., prefers analogies)\n- Emotional tone (e.g., frustration detected)\n- Past sessions (e.g., last quiz score, modding attempts)\nüîß Memory Layers:\n- Short-Term Memory: LangChain ConversationBufferMemory or SummaryMemory\n- Durable Memory: Redis, JSON store, or LangChain VectorStoreRetrieverMemory\n- Emotional Context: Sentiment analysis via nltk or HuggingFace models\nüßô Example:\nmemory = {\n  \"student_name\": \"Harsh\",\n  \"prefers_explanations\": \"with analogies\",\n  \"last_quiz_score\": 80,\n  \"frustration_level\": \"low\"\n}\n\n\nUse this to:\n- Personalize prompts\n- Adapt tone\n- Suggest next steps\n\nüß† How They Work Together\n- User Input ‚Üí Parsed by NLP + Intent Classifier\n- Brain Core ‚Üí Routes to correct Tool Module\n- Tool Module ‚Üí Executes task, returns result\n- Memory Context ‚Üí Refines response tone, format, and suggestions\n- Prompt Engine ‚Üí Wraps response in magical, student-friendly language\n Memory Context ‚Äì Adaptive Intelligence\nJarvis becomes magical when it remembers:\n- Student preferences (e.g., prefers analogies)\n- Emotional tone (e.g., frustration detected)\n- Past sessions (e.g., last quiz score, modding attempts)\nüîß Memory Layers:\n- Short-Term Memory: LangChain ConversationBufferMemory or SummaryMemory\n- Durable Memory: Redis, JSON store, or LangChain VectorStoreRetrieverMemory\n- Emotional Context: Sentiment analysis via nltk or HuggingFace models\n Tool Modules ‚Äì Specialized Executors\nEach feature lives in its own module, callable by the Brain Core.\nüîß Examples:\n- grammar_tool.py ‚Üí grammar correction via spaCy + transformers\n- quiz_generator.py ‚Üí LangChain + generate_quiz\n- mod_parser.py ‚Üí Minecraft config validator (regex + AST)\n- vision_module.py ‚Üí OpenCV + OCR\n- weather_fetcher.py ‚Üí REST API to OpenWeatherMap\n\nWould you like me to scaffold the Python folder structure for this? I can lay out brain_core.py, tools/, memory/, and prompts/ with example code for each. Or we can start with one module‚Äîlike the modding parser or quiz generator‚Äîand build it out together.\nFormat your response with clear sections, code examples where helpful, and specific file/line references. Use emojis to make it engaging (üß† for brain updates, üîß for fixes, ‚ú® for enhancements) "
  }
}